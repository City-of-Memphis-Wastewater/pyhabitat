pyhabitat üß≠
An Introspection Library for Python Environments and Builds
pyhabitat is a lightweight library for Python build and environment introspection. It accurately and securely determines the execution context of a running script by providing definitive checks for:

OS and Environments: Operating Systems and common container/emulation environments (e.g., Termux, iSH).
Build States: Application build systems (e.g., PyInstaller, pipx, zipapp).
GUI Backends: Availability of graphical toolkits (e.g., Matplotlib, Tkinter).

Stop writing verbose sys.platform and environment variable checks. Use pyhabitat to implement clean, architectural logic based on the execution habitat.

Read the code on github. üåê

üì¶ Installation
pip install pyhabitat



 üß† Motivation 

This library is especially useful for leveraging Python in mobile environments (Termux on Android and iSH on iOS), which often have particular limitations and require special handling. For example, it helps automate work-arounds like using localhost plotting when matplotlib is unavailable or web-based interfaces when tkinter is missing.
Our team is fundamentally driven by enabling mobile computing for true utility applications, leveraging environments like Termux (Android) and iSH (iOS). This includes highly practical solutions, such as deploying a lightweight Python web server (e.g., Flask, http.server, FastAPI) directly on a handset, or orchestrating full-stack, utility-grade applications that allow technicians to manage data and systems right from their mobile device in a way that is cross-platform and not overly catered to the App Store.
Another key goal of this project is to facilitate the orchestration of wider system installation for pipx CLI tools for additional touch points, like context menus and widgets.
Ultimately, City-of-Memphis-Wastewater aims to produce reference-quality code for the documented proper approach. We recognize that many people (and bots) are searching for ideal solutions, and our functions are built upon extensive research and testing to go beyond simple platform.system() checks.




 üöÄ Features 


Definitive Environment Checks: Rigorous checks catered to Termux and iSH (iOS Alpine). Accurate, typical modern detection for Windows, macOS (Apple), Linux, FreeBSD, Android.
GUI Availability: Rigorous, cached checks to determine if the environment supports a graphical popup window (Tkinter/Matplotlib TkAgg) or just headless image export (Matplotlib Agg).
Build/Packaging Detection: Reliable detection of standalone executables built by tools like PyInstaller, Python zipapps (.pyz), Python source scripts (.py), and correct identification and exclusion of pipx-managed virtual environments.
Executable Type Inspection: Uses file magic numbers (ELF, MZ, Mach-O) to confirm if a script or specified path is a monolithic, frozen binary (non-pipx) or zipapp.





 üìö Function Reference 

OS and Environment Checking
Key question: "What is this running on?"



Function
Description



on_windows()
Returns True on Windows.


on_apple()
Returns True on macOS (Darwin).


on_linux()
Returns True on Linux in general.


on_termux()
Returns True if running in the Termux Android environment.


on_ish_alpine()
Returns True if running in the iSH Alpine Linux iOS emulator.


on_android()
Returns True on any Android-based Linux environment.


on_freebsd()
Returns True on FreeBSD.


in_repl()
Returns True if the user is currently in a Python REPL (hasattr(sys, 'ps1')).


Packaging and Build Checking
Key question: "What is the character of my executable or my build state?"
When running a script or module (e.g., python -m pyhabitat), path-based functions check the running script (sys.argv[0], typically a .py file like pyhabitat/__main__.py). In the REPL, sys.argv[0] is empty, resolving to the current directory, causing these functions to return False unless a specific path is provided. Interpreter checks (e.g., is_elf(interp_path())) use sys.executable.



Function
Description



as_frozen()
Returns True if the script is running as a standalone executable (any bundler), based on getattr(sys, 'frozen', False).


as_pyinstaller()
Returns True if the script is frozen and generated by PyInstaller (has _MEIPASS).


is_python_script(path=None)
Returns True if the script or specified path is a Python source file (.py), useful for detecting scripts run via python script.py or python -m module. If path=None, checks the resolved path of the running script (sys.argv[0]) using Path.resolve().


is_pipx(path=None)
Returns True if the script or specified path is from a pipx-managed virtual environment. If path=None, checks the resolved path of the running script or executable (sys.argv[0]) using Path.resolve().


is_elf(path=None)
Returns True if the script or specified path is an ELF binary (Linux standalone executable, non-pipx). If path=None, checks the resolved path of the running script or executable (sys.argv[0]) using Path.resolve().


is_pyz(path=None)
Returns True if the script or specified path is a Python zipapp (.pyz, non-pipx). If path=None, checks the resolved path of the running script or executable (sys.argv[0]) using Path.resolve().


is_windows_portable_executable(path=None)
Returns True if the script or specified path is a Windows PE binary (MZ header, non-pipx). If path=None, checks the resolved path of the running script or executable (sys.argv[0]) using Path.resolve().


is_macos_executable(path=None)
Returns True if the script or specified path is a macOS Mach-O binary (non-pipx). If path=None, checks the resolved path of the running script or executable (sys.argv[0]) using Path.resolve().


Capability Checking
Key Question: "What could I do next?"



Function
Description



tkinter_is_available()
Checks if Tkinter is imported and can successfully create a window.


matplotlib_is_available_for_gui_plotting(termux_has_gui=False)
Checks for Matplotlib and its TkAgg backend, required for interactive plotting.


matplotlib_is_available_for_headless_image_export()
Checks for Matplotlib and its Agg backend, required for saving images without a GUI.


interactive_terminal_is_available()
Checks if standard input and output streams are connected to a TTY (allows safe use of interactive prompts).


web_browser_is_available()
Checks if a web browser can be launched in the current environment (allows safe use of web-based prompts and localhost plotting).


Utility



Function
Description



edit_textfile(path)
Opens a text file for editing using the default editor (Windows, Linux, macOS) or nano in Termux/iSH. In REPL mode, prints an error. Uses Path.resolve() for stable path handling.


interp_path(print_path=False)
Returns the path to the Python interpreter binary (sys.executable). Optionally prints the path. Returns an empty string if unavailable.


main()
Prints a comprehensive environment report, including interpreter, environment, build, operating system, and capability checks. Run via python -m pyhabitat or import pyhabitat; pyhabitat.main() in the REPL.






 üíª Usage Examples 

The module exposes all detection functions and main() directly for easy access.
0. Current Use
The pipeline-eds package uses the pyhabitat library to handle configuration and plotting, among other things.
1. Running the Environment Report
Run a comprehensive environment report from the command line or REPL to inspect the interpreter (sys.executable), running script (sys.argv[0]), build state, operating system, and capabilities.
python -m pyhabitat

# In the Python REPL
import pyhabitat as ph
ph.main()

2. Checking Environment and Build Type
from pyhabitat import on_termux, on_windows, is_pipx, is_python_script, as_frozen

if is_pipx():
    print("Running inside a pipx virtual environment. This is not a standalone binary.")
elif as_frozen():
    print("Running as a frozen executable (PyInstaller, cx_Freeze, etc.).")
elif is_python_script():
    print("Running as a Python source script (.py).")
elif on_termux():
    # Expected cases:
    # - pkg install python-numpy python-cryptography
    # - Avoiding matplotlib unless the user explicitly confirms that termux_has_gui=True in matplotlib_is_available_for_gui_plotting().
    # - Auto-selection of 'termux-open-url' and 'xdg-open' in logic.
    # - Installation on the system, like orchestrating the construction of Termux Widget entries in ~/.shortcuts.
    print("Running in the Termux environment on Android.")
elif on_windows():
    print("Running on Windows.")

3. Checking GUI and Plotting Availability
from pyhabitat import matplotlib_is_available_for_gui_plotting, matplotlib_is_available_for_headless_image_export

if matplotlib_is_available_for_gui_plotting(termux_has_gui=True):
    # We can safely call plt.show()
    print("GUI plotting is available! Using TkAgg backend.")
    import matplotlib.pyplot as plt
    plt.figure()
    plt.show()
elif matplotlib_is_available_for_headless_image_export():
    # We must save the plot to a file or buffer
    print("GUI unavailable, but headless image export is possible.")
    # Code to use 'Agg' backend and save to disk...
else:
    print("Matplotlib is not installed or the environment is too restrictive for plotting.")

4. Text Editing
Use this function to smoothly open a text file for editing.Ideal use case: Edit a configuration file, if prompted by a CLI command like 'config --textedit'.
from pathlib import Path
from pyhabitat import edit_textfile
edit_textfile(path=Path('./config.json'))

5. Checking Interpreter and Executable
Use these functions to inspect the interpreter and executable paths.
from pyhabitat import in_repl, interp_path, is_elf, is_pyz, is_python_script
if in_repl():
    print("Running in Python REPL")
else:
    print(f"Interpreter path: {interp_path()}")
    print(f"Is interpreter ELF: {is_elf(interp_path())}")
    print(f"Is script PYZ: {is_pyz()}")
    print(f"Is script Python source: {is_python_script()}")




ü§ù Contributing
Contributions are welcome! If you find an environment or build system that is not correctly detected (e.g., a new container or a specific bundler), please open an issue or submit a pull request with the relevant detection logic.
üìÑ License
This project is licensed under the MIT License. See the LICENSE file for details.

